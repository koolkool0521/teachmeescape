<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìœ ë ¹ ì„±ì˜ íƒˆì¶œ: í˜‘ë™ ì—ë””ì…˜</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Nanum+Gothic:wght@400;700&family=Black+Han+Sans&family=Gowun+Batang:wght@700&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #050000;
            color: #ffcccc;
            font-family: 'Nanum Gothic', sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 1000px;
            height: 650px;
            box-shadow: 0 0 50px #520000;
            border: 4px solid #3d0a0a;
            background-color: #1a0505;
            overflow: hidden;
            background: #110505; 
        }

        /* UI Overlays */
        #ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 20;
            text-shadow: 2px 2px 0 #000;
        }

        .status-box {
            background: rgba(0, 0, 0, 0.85);
            padding: 8px 15px;
            border: 2px solid #800000;
            border-radius: 5px;
            color: #fff;
            font-size: 1rem;
            font-family: 'Gowun Batang', serif;
        }

        /* Modals */
        .modal {
            display: none;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: #1a1a1a;
            border: 4px solid #a83232;
            padding: 20px;
            z-index: 100;
            text-align: center;
            box-shadow: 0 0 50px rgba(255, 0, 0, 0.6);
            width: 80%;
            max-width: 600px;
        }

        .modal h2 {
            color: #ff4d4d;
            font-family: 'Gowun Batang', serif;
            margin-top: 0;
        }

        .modal-content {
            text-align: left;
            margin: 15px 0;
            background: #0f0f0f;
            padding: 15px;
            border: 1px solid #444;
            max-height: 300px;
            overflow-y: auto;
            line-height: 1.6;
        }

        .btn {
            padding: 10px 20px;
            background: #5c0000;
            color: white;
            border: 1px solid #ff0000;
            cursor: pointer;
            font-family: 'Nanum Gothic', sans-serif;
            margin: 5px;
            transition: 0.2s;
        }
        .btn:hover { background: #800000; }
        
        .option-btn {
            display: block;
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: #330000;
            color: #ccc;
            border: 1px solid #555;
            cursor: pointer;
            text-align: left;
        }
        .option-btn:hover { background: #550000; }

        /* Login Screen */
        #login-screen {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 200;
        }

        #login-box {
            background: #220505;
            padding: 40px;
            border: 4px solid #ff0000;
            text-align: center;
        }

        input[type="text"] {
            padding: 10px;
            font-size: 1.1rem;
            margin: 10px 0;
            width: 200px;
            text-align: center;
        }
        
        /* Game Over Screen (No Reload) */
        #gameover-screen {
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(50,0,0,0.9);
            z-index: 190;
        }

        /* Scanlines */
        .scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%);
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
            opacity: 0.3;
        }

        #hint-display {
            color: #ffff00;
            font-weight: bold;
            font-size: 1.2rem;
            margin-top: 10px;
            text-align: center;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="1000" height="650"></canvas>
    <div class="scanlines"></div>

    <!-- UI -->
    <div id="ui-layer">
        <div class="status-box">STAGE: <span id="stage-display">1</span> - <span id="stage-name">ì§€í•˜ ê°ì˜¥</span></div>
        <div class="status-box" id="password-hint-box">íšë“í•œ ì•”í˜¸ íŒíŠ¸: <span id="hint-text">ì—†ìŒ</span></div>
        <div class="status-box">ëª©ìˆ¨: <span id="lives-display">â¤â¤â¤â¤â¤</span></div>
    </div>

    <!-- Login -->
    <div id="login-screen">
        <div id="login-box">
            <h1 style="color:red; font-family:'Black Han Sans'; margin:0 0 20px 0; font-size: 3rem;">BLOOD CASTLE<br><span style="font-size:1.5rem">Co-op Escape</span></h1>
            <p style="color:#ccc;">ë‹‰ë„¤ì„ì„ ì…ë ¥í•˜ê³  ì…ì¥í•˜ì„¸ìš”.</p>
            <input type="text" id="nickname-input" placeholder="ë‹‰ë„¤ì„" maxlength="8">
            <br>
            <button class="btn" onclick="joinGame()">ì…ì¥í•˜ê¸°</button>
            <p style="color:#888; font-size: 0.8rem; margin-top: 10px;">TIP: ëª¬ìŠ¤í„°ì˜ ê°‘ì‘ìŠ¤ëŸ¬ìš´ ê°€ì‹œ ê³µê²©ì„ ì¡°ì‹¬í•˜ì„¸ìš”!</p>
        </div>
    </div>
    
    <!-- Game Over Screen -->
    <div id="gameover-screen">
        <h1 style="color:red; font-size:4rem; margin-bottom:20px;">GAME OVER</h1>
        <p style="color:white; font-size:1.2rem; margin-bottom:30px;">ë‹¹ì‹ ì˜ ì˜í˜¼ì€ ì´ê³³ì— ê°‡í˜”ìŠµë‹ˆë‹¤...</p>
        <button class="btn" onclick="retryStage()" style="font-size:1.5rem; padding:15px 30px;">ì¬ë„ì „ (Retry)</button>
    </div>

    <!-- Quiz Modal -->
    <div id="quiz-modal" class="modal">
        <h2 id="quiz-subject">ë¬¸ì œ</h2>
        <div id="quiz-content" class="modal-content"></div>
        <div id="quiz-options"></div>
    </div>

    <!-- Gate Modal (Password) -->
    <div id="gate-modal" class="modal">
        <h2>íƒˆì¶œêµ¬ ë´‰ì¸</h2>
        <div class="modal-content">
            ì´ ë¬¸ì„ ì—´ë ¤ë©´ ê° ë°©ì—ì„œ ì–»ì€ íŒíŠ¸ë¥¼ ì¡°í•©í•˜ì—¬ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì•¼ í•©ë‹ˆë‹¤.
            <br><br>
            <input type="text" id="gate-password" placeholder="ë¹„ë°€ë²ˆí˜¸ ì…ë ¥" style="width:80%;">
        </div>
        <button class="btn" onclick="checkGatePassword()">ë¬¸ ì—´ê¸°</button>
        <button class="btn" onclick="closeGateModal()">ë‹«ê¸°</button>
    </div>

    <!-- Message Overlay -->
    <div id="message-overlay" style="position:absolute; top:40%; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.8); padding:20px; border:2px solid red; color:white; display:none; z-index:150; font-size:1.5rem; text-align:center;"></div>
</div>

<!-- Firebase SDKs -->
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, collection, doc, setDoc, onSnapshot, addDoc, query, orderBy, limit, serverTimestamp, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // --- Firebase Init ---
    let firebaseConfig;
    let appId;

    // [ì¤‘ìš”] GitHub Pages ë“± ì™¸ë¶€ í˜¸ìŠ¤íŒ… ì‹œ ì•„ë˜ 'else' ë¸”ë¡ì˜ ì£¼ì„ì„ í•´ì œí•˜ê³  ë³¸ì¸ì˜ Firebase ì„¤ì •ê°’ì„ ì…ë ¥í•˜ì„¸ìš”.
    if (typeof __firebase_config !== 'undefined') {
        // ì´ ë¸”ë¡ì€ Canvas/Preview í™˜ê²½ì—ì„œ ì‘ë™í•©ë‹ˆë‹¤.
        firebaseConfig = JSON.parse(__firebase_config);
        appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app';
    } else {
        // [ì—¬ê¸°ì— ë³¸ì¸ì˜ Firebase ì„¤ì •ì„ ë„£ìœ¼ì„¸ìš”]
        firebaseConfig = {
            apiKey: "AIzaSyBsPHiR88AhOo-mT3zbZZpGc-tiWcQLXPA",
            authDomain: "escape-e3f1d.firebaseapp.com",
            projectId: "escape-e3f1d",
            storageBucket: "escape-e3f1d.firebasestorage.app",
            messagingSenderId: "87061489514",
            appId: "1:87061489514:web:8ad7144834626ac6f5e713",
            measurementId: "G-0QLEQD1BS2"
        };
        // Firestore ê²½ë¡œì— ì‚¬ìš©í•  ì•± ID ì„¤ì •
        appId = "escape-e3f1d"; 
    }

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    let currentUser = null;
    let myPlayerId = null;
    let nickname = "Player";

    // --- Game Assets (Images) ---
    function createSafeImage(src) {
        const img = new Image();
        img.crossOrigin = "Anonymous"; 
        img.src = src;
        return img;
    }

    const assets = {
        player: createSafeImage("https://cdn-icons-png.flaticon.com/512/3408/3408545.png"), 
        monsterFly: createSafeImage("https://cdn-icons-png.flaticon.com/512/3062/3062634.png"),
        monsterCrawl: createSafeImage("https://cdn-icons-png.flaticon.com/512/2931/2931692.png"),
        bg1: createSafeImage("https://images.unsplash.com/photo-1599587440406-d7607775531d?q=80&w=1080&auto=format&fit=crop"), // Dungeon
        bg2: createSafeImage("https://images.unsplash.com/photo-1518640165980-d3e0e2aa6c1e?q=80&w=1080&auto=format&fit=crop"), // Hall
        bg3: createSafeImage("https://images.unsplash.com/photo-1505506874110-6a7a69069a08?q=80&w=1080&auto=format&fit=crop"), // Spire
        items: {
            book: createSafeImage("https://cdn-icons-png.flaticon.com/512/3330/3330314.png"),
            chest: createSafeImage("https://cdn-icons-png.flaticon.com/512/3014/3014798.png"),
            potion: createSafeImage("https://cdn-icons-png.flaticon.com/512/867/867927.png")
        }
    };
    
    // --- Question Bank (6th Grade Curriculum - Expanded) ---
    const questionBank = [
        // ìˆ˜í•™
        { q: "[ìˆ˜í•™] ì›ì˜ ë„“ì´ë¥¼ êµ¬í•˜ëŠ” ê³µì‹ì€?", options: ["ë°˜ì§€ë¦„Ã—ë°˜ì§€ë¦„Ã—ì›ì£¼ìœ¨", "ì§€ë¦„Ã—ì›ì£¼ìœ¨", "ë°‘ë³€Ã—ë†’ì´", "ê°€ë¡œÃ—ì„¸ë¡œ"], a: 0 },
        { q: "[ìˆ˜í•™] ì§€ë¦„ì´ 10cmì¸ ì›ì˜ ì›ì£¼ëŠ”? (ì›ì£¼ìœ¨: 3.14)", options: ["15.7cm", "31.4cm", "314cm", "10cm"], a: 1 },
        { q: "[ìˆ˜í•™] ë¹„ë¡€ì‹ 2:3 = 4:â–¡ ì—ì„œ â–¡ëŠ”?", options: ["5", "6", "7", "8"], a: 1 },
        { q: "[ìˆ˜í•™] ë°‘ë©´ì˜ ë°˜ì§€ë¦„ì´ 5, ë†’ì´ê°€ 10ì¸ ì›ê¸°ë‘¥ì˜ ë¶€í”¼ëŠ”? (ì›ì£¼ìœ¨: 3)", options: ["250", "750", "150", "500"], a: 1 }, 
        { q: "[ìˆ˜í•™] ì§ìœ¡ë©´ì²´ì˜ ê²‰ë„“ì´ë¥¼ êµ¬í•˜ëŠ” ë°©ë²•ì€?", options: ["ì—¬ì„¯ ë©´ì˜ ë„“ì´ì˜ í•©", "ë°‘ë„“ì´ Ã— ë†’ì´", "ê°€ë¡œ Ã— ì„¸ë¡œ", "ë°‘ë³€ Ã— ë†’ì´ Ã· 2"], a: 0 },
        { q: "[ìˆ˜í•™] 3.5 Ã· 0.5 ì˜ ê°’ì€?", options: ["5", "6", "7", "8"], a: 2 },
        { q: "[ìˆ˜í•™] ì›ê¸°ë‘¥ì˜ ì „ê°œë„ì—ì„œ ì˜†ë©´ì˜ ê°€ë¡œ ê¸¸ì´ëŠ” ë¬´ì—‡ê³¼ ê°™ì€ê°€?", options: ["ë°‘ë©´ì˜ ì§€ë¦„", "ë°‘ë©´ì˜ ì›ì£¼", "ì›ê¸°ë‘¥ì˜ ë†’ì´", "ë°‘ë©´ì˜ ë°˜ì§€ë¦„"], a: 1 },
        { q: "[ìˆ˜í•™] ë¹„ë¡€ë°°ë¶„: ì‚¬íƒ• 10ê°œë¥¼ 2:3ìœ¼ë¡œ ë‚˜ëˆ„ë©´?", options: ["2ê°œ, 8ê°œ", "4ê°œ, 6ê°œ", "5ê°œ, 5ê°œ", "3ê°œ, 7ê°œ"], a: 1 },
        { q: "[ìˆ˜í•™] ìŒ“ê¸°ë‚˜ë¬´ì˜ ê°œìˆ˜ë¥¼ ì…€ ë•Œ ë³´ì´ì§€ ì•ŠëŠ” ë¶€ë¶„ë„ ìƒê°í•´ì•¼ í•œë‹¤. (O/X)", options: ["O", "X"], a: 0 },
        { q: "[ìˆ˜í•™] ê°ê¸°ë‘¥ì˜ ì´ë¦„ì€ ë¬´ì—‡ì— ë”°ë¼ ê²°ì •ë˜ëŠ”ê°€?", options: ["ë†’ì´", "ì˜†ë©´ì˜ ëª¨ì–‘", "ë°‘ë©´ì˜ ëª¨ì–‘", "ëª¨ì„œë¦¬ì˜ ìˆ˜"], a: 2 },
        { q: "[ìˆ˜í•™] 5/6 Ã· 2/3 ì˜ ê³„ì‚° ê²°ê³¼ëŠ”?", options: ["1ê³¼ 1/4", "1ê³¼ 1/2", "5/9", "5/4"], a: 0 },

        // ì‚¬íšŒ
        { q: "[ì‚¬íšŒ] ìš°ë¦¬ë‚˜ë¼ì˜ ì…ë²• ê¸°ê´€ì€?", options: ["êµ­íšŒ", "ë²•ì›", "ì •ë¶€", "ê²½ì°°ì²­"], a: 0 },
        { q: "[ì‚¬íšŒ] ì„¸ê³„ì—ì„œ ê°€ì¥ í° ëŒ€ë¥™ì€?", options: ["ì•„ì‹œì•„", "ì•„í”„ë¦¬ì¹´", "ìœ ëŸ½", "ë‚¨ì•„ë©”ë¦¬ì¹´"], a: 0 },
        { q: "[ì‚¬íšŒ] ì§€êµ¬ì´Œ í™˜ê²½ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•œ êµ­ì œ í˜‘ì•½ì´ ì•„ë‹Œ ê²ƒì€?", options: ["íŒŒë¦¬ í˜‘ì •", "ë„ì¿„ ì˜ì •ì„œ", "ëŒì‚¬ë¥´ í˜‘ì•½", "ê°•í™”ë„ ì¡°ì•½"], a: 3 },
        { q: "[ì‚¬íšŒ] êµ­ë¯¼ì˜ ê¶Œë¦¬ë¥¼ ì¹¨í•´ë°›ì•˜ì„ ë•Œ êµ¬ì œë¥¼ ìš”ì²­í•˜ëŠ” ê³³ì€?", options: ["í—Œë²•ì¬íŒì†Œ", "êµ­ì„¸ì²­", "êµìœ¡ë¶€", "ìš°ì²´êµ­"], a: 0 },
        { q: "[ì‚¬íšŒ] 6.25 ì „ìŸì´ ì¼ì–´ë‚œ ì—°ë„ëŠ”?", options: ["1945ë…„", "1950ë…„", "1953ë…„", "1960ë…„"], a: 1 },
        { q: "[ì‚¬íšŒ] ë¯¼ì£¼ì£¼ì˜ì˜ ê¸°ë³¸ ì›ì¹™ì´ ì•„ë‹Œ ê²ƒì€?", options: ["êµ­ë¯¼ ì£¼ê¶Œ", "ê¶Œë ¥ ë¶„ë¦½", "ì…í—Œ ì£¼ì˜", "ë…ì¬ ì •ì¹˜"], a: 3 },
        { q: "[ì‚¬íšŒ] ì´ì›ƒ ë‚˜ë¼ ì¤‘êµ­ì˜ ìˆ˜ë„ëŠ”?", options: ["ë² ì´ì§•", "ìƒí•˜ì´", "ë„ì¿„", "ì„œìš¸"], a: 0 },
        { q: "[ì‚¬íšŒ] ë²•ì„ ë§Œë“¤ê³  ê³ ì¹˜ëŠ” ì¼ì„ í•˜ëŠ” ê³³ì€?", options: ["êµ­íšŒ", "ì •ë¶€", "ë²•ì›", "ì‹œì²­"], a: 0 },
        { q: "[ì‚¬íšŒ] ìš°ë¦¬ë‚˜ë¼ ê²½ì œ ì„±ì¥ì˜ íŠ¹ì§•ìœ¼ë¡œ ì•Œë§ì§€ ì•Šì€ ê²ƒì€?", options: ["ìˆ˜ì¶œ ì¤‘ì‹¬", "ì²¨ë‹¨ ì‚°ì—… ë°œë‹¬", "ë†ì—… ì¤‘ì‹¬ ì‚¬íšŒ ìœ ì§€", "êµ­ë¯¼ ì†Œë“ ì¦ê°€"], a: 2 },
        { q: "[ì‚¬íšŒ] ê³µì •í•œ ì¬íŒì„ ìœ„í•´ ë²•ì›ì€ ë‹¤ë¥¸ êµ­ê°€ ê¸°ê´€ì˜ ê°„ì„­ì„ ë°›ì§€ ì•ŠëŠ”ë‹¤. ì´ê²ƒì€?", options: ["ì‚¬ë²•ê¶Œì˜ ë…ë¦½", "ì‚¼ê¶Œ ë¶„ë¦½", "ì§€ë°© ìì¹˜", "êµ­ë¯¼ íˆ¬í‘œ"], a: 0 },
        
        // ê³¼í•™
        { q: "[ê³¼í•™] ì „ê¸°ê°€ ì˜ í†µí•˜ëŠ” ë¬¼ì²´ë¥¼ ë¬´ì—‡ì´ë¼ í•˜ëŠ”ê°€?", options: ["ë„ì²´", "ë¶€ë„ì²´", "ë°˜ë„ì²´", "ì´ˆì „ë„ì²´"], a: 0 },
        { q: "[ê³¼í•™] ì—°ì†Œì˜ 3ìš”ì†Œê°€ ì•„ë‹Œ ê²ƒì€?", options: ["íƒˆ ë¬¼ì§ˆ", "ì‚°ì†Œ", "ë°œí™”ì  ì´ìƒì˜ ì˜¨ë„", "ì´ì‚°í™”íƒ„ì†Œ"], a: 3 },
        { q: "[ê³¼í•™] ê³„ì ˆì´ ë³€í•˜ëŠ” ê¹Œë‹­ì€?", options: ["ì§€êµ¬ ìì „ì¶•ì´ ê¸°ìš¸ì–´ì§„ ì±„ ê³µì „í•´ì„œ", "íƒœì–‘ê³¼ì˜ ê±°ë¦¬ê°€ ë³€í•´ì„œ", "ì§€êµ¬ê°€ ìì „í•´ì„œ", "ë‹¬ì˜ ì¸ë ¥ ë•Œë¬¸ì—"], a: 0 },
        { q: "[ê³¼í•™] ì‹ë¬¼ì´ ì–‘ë¶„ì„ ë§Œë“œëŠ” ê³¼ì •ì€?", options: ["ê´‘í•©ì„±", "í˜¸í¡", "ì¦ì‚° ì‘ìš©", "ì†Œí™”"], a: 0 },
        { q: "[ê³¼í•™] ìš°ë¦¬ ëª¸ì—ì„œ í˜ˆì•¡ì„ ìˆœí™˜ì‹œí‚¤ëŠ” ê¸°ê´€ì€?", options: ["ì‹¬ì¥", "ìœ„", "í", "ê°„"], a: 0 },
        { q: "[ê³¼í•™] ë‚®ê³¼ ë°¤ì´ ìƒê¸°ëŠ” ì´ìœ ëŠ”?", options: ["ì§€êµ¬ì˜ ìì „", "ì§€êµ¬ì˜ ê³µì „", "ë‹¬ì˜ ê³µì „", "íƒœì–‘ì˜ ì´ë™"], a: 0 },
        { q: "[ê³¼í•™] ì‚°ì†Œì˜ ì„±ì§ˆë¡œ ì•Œë§ì€ ê²ƒì€?", options: ["ìƒ‰ê¹”ì´ ìˆë‹¤", "ëƒ„ìƒˆê°€ ìˆë‹¤", "ë‹¤ë¥¸ ë¬¼ì§ˆì´ íƒ€ëŠ” ê²ƒì„ ë•ëŠ”ë‹¤", "ë¶ˆì„ ë„ëŠ” ì„±ì§ˆì´ ìˆë‹¤"], a: 2 },
        { q: "[ê³¼í•™] ë¶ìª½ í•˜ëŠ˜ì—ì„œ ë³¼ ìˆ˜ ìˆëŠ” ë³„ìë¦¬ëŠ”?", options: ["ì˜¤ë¦¬ì˜¨ìë¦¬", "ì „ê°ˆìë¦¬", "í°ê³°ìë¦¬(ë¶ë‘ì¹ ì„±)", "ì‚¬ììë¦¬"], a: 2 },
        { q: "[ê³¼í•™] ìš°ë¦¬ ëª¸ì˜ ì†Œí™” ê¸°ê´€ì´ ì•„ë‹Œ ê²ƒì€?", options: ["ìœ„", "ì†Œì¥", "ëŒ€ì¥", "ì‹¬ì¥"], a: 3 },
        { q: "[ê³¼í•™] ë Œì¦ˆì˜ ì¢…ë¥˜ ì¤‘ ë¹›ì„ ëª¨ìœ¼ëŠ” ì„±ì§ˆì´ ìˆëŠ” ê²ƒì€?", options: ["ë³¼ë¡ ë Œì¦ˆ", "ì˜¤ëª© ë Œì¦ˆ", "í‰ë©´ ë Œì¦ˆ", "ì„ ê¸€ë¼ìŠ¤"], a: 0 },

        // ì˜ì–´
        { q: "[ì˜ì–´] 'ë‚˜ëŠ” ì–´ì œ í•™êµì— ê°”ë‹¤'ì˜ ì˜¬ë°”ë¥¸ ì˜ì‘ì€?", options: ["I go to school yesterday.", "I went to school yesterday.", "I will go to school.", "I am going to school."], a: 1 },
        { q: "[ì˜ì–´] ë¯¸ë˜ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ì¡°ë™ì‚¬ëŠ”?", options: ["did", "will", "do", "can"], a: 1 },
        { q: "[ì˜ì–´] 'í™˜ê²½'ì„ ì˜ì–´ë¡œ í•˜ë©´?", options: ["Environment", "Government", "Apartment", "Department"], a: 0 },
        { q: "[ì˜ì–´] ë¹ˆì¹¸ì— ì•Œë§ì€ ë§: He _____ happy.", options: ["is", "are", "am", "be"], a: 0 },
        { q: "[ì˜ì–´] 'Museum'ì˜ ëœ»ì€?", options: ["ë°•ë¬¼ê´€", "ë„ì„œê´€", "í•™êµ", "ë³‘ì›"], a: 0 },
        { q: "[ì˜ì–´] 'What did you do?' ì˜ ëœ»ì€?", options: ["ë„ˆëŠ” ë¬´ì—‡ì„ í•  ê±°ë‹ˆ?", "ë„ˆëŠ” ë¬´ì—‡ì„ í–ˆë‹ˆ?", "ë„ˆëŠ” ë¬´ì—‡ì„ ì¢‹ì•„í•˜ë‹ˆ?", "ë„ˆëŠ” ì–´ë””ì— ê°€ë‹ˆ?"], a: 1 },
        { q: "[ì˜ì–´] ë‹¤ìŒ ì¤‘ ê³¼ì¼ì´ ì•„ë‹Œ ê²ƒì€?", options: ["Apple", "Banana", "Carrot", "Grape"], a: 2 },
        { q: "[ì˜ì–´] 12ì›”ì„ ì˜ì–´ë¡œ?", options: ["October", "November", "December", "January"], a: 2 },
        { q: "[ì˜ì–´] 'Can you help me?'ì— ëŒ€í•œ ëŒ€ë‹µìœ¼ë¡œ ì•Œë§ì€ ê²ƒì€?", options: ["Yes, I can.", "No, I don't.", "Yes, I am.", "No, thank you."], a: 0 },
        { q: "[ì˜ì–´] 'ì¹˜í†µ'ì„ ì˜ì–´ë¡œ í•˜ë©´?", options: ["Headache", "Toothache", "Stomachache", "Cold"], a: 1 },

        // êµ­ì–´/ìƒì‹
        { q: "[êµ­ì–´] ì£¼ì¥ì„ ë’·ë°›ì¹¨í•˜ëŠ” ë‚´ìš©ì„ ë¬´ì—‡ì´ë¼ í•˜ëŠ”ê°€?", options: ["ê·¼ê±°", "ì„œë¡ ", "ê²°ë¡ ", "ì˜ˆì‹œ"], a: 0 },
        { q: "[êµ­ì–´] 'ë°œì´ ë„“ë‹¤'ì˜ ê´€ìš©ì  ì˜ë¯¸ëŠ”?", options: ["ì•„ëŠ” ì‚¬ëŒì´ ë§ë‹¤", "ë°œ ì‚¬ì´ì¦ˆê°€ í¬ë‹¤", "ì˜ ê±·ëŠ”ë‹¤", "ì‹ ë°œì´ í¬ë‹¤"], a: 0 },
        { q: "[êµ­ì–´] ì´ì•¼ê¸°ë¥¼ ì´ëŒì–´ê°€ëŠ” ì£¼ì²´ë¥¼ ë¬´ì—‡ì´ë¼ í•˜ëŠ”ê°€?", options: ["ì„œìˆ ì", "ë…ì", "ì‘ê°€", "ì¶œíŒì‚¬"], a: 0 },
        { q: "[êµ­ì–´] í›ˆë¯¼ì •ìŒì„ ì°½ì œí•œ ì™•ì€?", options: ["ì„¸ì¢…ëŒ€ì™•", "ì´ìˆœì‹ ", "ì •ì¡°", "ì˜ì¡°"], a: 0 },
        { q: "[ìƒì‹] 3.1ì ˆì€ ëª‡ ì›” ë©°ì¹ ì¸ê°€?", options: ["3ì›” 1ì¼", "3ì›” 3ì¼", "3ì›” 31ì¼", "1ì›” 3ì¼"], a: 0 },
        { q: "[êµ­ì–´] ê´‘ê³ ì˜ ëª©ì ì€?", options: ["ì •ë³´ ì „ë‹¬ ë° ì„¤ë“", "ë¹„íŒ", "ê°ë™", "ê¸°ë¡"], a: 0 },
        { q: "[êµ­ì–´] 'ë¯¸ì—­êµ­ì„ ë¨¹ë‹¤'ì˜ ê´€ìš©ì  ì˜ë¯¸ëŠ”?", options: ["ì‹œí—˜ì— ë–¨ì–´ì§€ë‹¤", "ìƒì¼ì„ ë§ë‹¤", "ë°°ê°€ ê³ í”„ë‹¤", "í™”ë¥¼ ë‚´ë‹¤"], a: 0 },
        { q: "[êµ­ì–´] ê¸€ì“´ì´ì˜ ê´€ì ì„ íŒŒì•…í•˜ëŠ” ë°©ë²•ìœ¼ë¡œ ì•Œë§ì§€ ì•Šì€ ê²ƒì€?", options: ["ì œëª©ì„ ì‚´í´ë³¸ë‹¤", "í‘œí˜„ì„ ì‚´í´ë³¸ë‹¤", "ê¸€ì“´ì´ì˜ ë‚˜ì´ë¥¼ ì¶”ì¸¡í•œë‹¤", "ê¸€ì˜ ë‚´ìš©ì„ íŒŒì•…í•œë‹¤"], a: 2 },
        { q: "[ìƒì‹] ì˜¬ë¦¼í”½ ì˜¤ë¥œê¸°ì˜ ìƒ‰ê¹”ì´ ì•„ë‹Œ ê²ƒì€?", options: ["íŒŒë‘", "ë…¸ë‘", "ê²€ì •", "ë³´ë¼"], a: 3 },
        { q: "[ìƒì‹] ëŒ€í•œë¯¼êµ­ êµ­ë³´ 1í˜¸ëŠ”?", options: ["ìˆ­ë¡€ë¬¸(ë‚¨ëŒ€ë¬¸)", "í¥ì¸ì§€ë¬¸", "ì„êµ´ì•”", "ë‹¤ë³´íƒ‘"], a: 0 }
    ];

    // --- Game State ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    let gameState = 'LOGIN'; 
    let stage = 1;
    let lives = 5;
    let collectedHints = []; 
    let currentPassword = ""; 
    let globalQuestionDeck = []; 

    // Map & Physics
    const TILE_SIZE = 50;
    const GRAVITY = 0.6;
    const JUMP_FORCE = -16; 
    const SPEED = 5;
    let map = [];
    let cameraX = 0;

    // Entities
    let player = { 
        x: 50, y: 200, w: 40, h: 40, 
        vx: 0, vy: 0, 
        grounded: false, facing: 1,
        invulnerable: 0 
    };
    let otherPlayers = {}; 
    let monsters = [];
    let puzzles = [];

    // --- Word Bank ---
    const wordBank = {
        1: ["HOPE", "LOVE", "LIFE", "KING", "LUCK", "STAR", "MOON", "LION", "GOLD", "WISH"], 
        2: ["BRAVE", "DREAM", "WORLD", "PEACE", "EARTH", "HAPPY", "SMILE", "WATER", "MUSIC", "START"], 
        3: ["TRUTH", "POWER", "LIGHT", "SPACE", "SMART", "HEART", "GLORY", "TRUST", "PRIDE", "FINAL"] 
    };

    // --- Puzzle Setup Data ---
    const stageLayouts = {
        1: {
            name: "ì§€í•˜ ê°ì˜¥ (Dungeon)",
            bg: assets.bg1,
            puzzleSpots: [
                { type: 'book', x: 200, y: 300 },
                { type: 'chest', x: 600, y: 150 },
                { type: 'potion', x: 1000, y: 400 },
                { type: 'book', x: 1400, y: 250 }
            ]
        },
        2: {
            name: "ìœ ë ¹ ì—°íšŒì¥ (Grand Hall)",
            bg: assets.bg2,
            puzzleSpots: [
                { type: 'book', x: 300, y: 200 },
                { type: 'chest', x: 800, y: 100 },
                { type: 'potion', x: 1200, y: 300 },
                { type: 'book', x: 1600, y: 150 },
                { type: 'chest', x: 2000, y: 250 }
            ]
        },
        3: {
            name: "ê²€ì€ ì²¨íƒ‘ (Dark Spire)",
            bg: assets.bg3,
            puzzleSpots: [
                { type: 'book', x: 400, y: 400 },
                { type: 'chest', x: 800, y: 200 },
                { type: 'potion', x: 1200, y: 450 },
                { type: 'book', x: 1600, y: 150 },
                { type: 'chest', x: 1900, y: 300 }
            ]
        }
    };

    // --- Helper: Shuffle Array ---
    function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    // --- Auth & Lobby ---
    window.joinGame = async () => {
        const input = document.getElementById('nickname-input');
        if(!input.value) return alert("ë‹‰ë„¤ì„ì„ ì…ë ¥í•˜ì„¸ìš”.");
        nickname = input.value;
        
        globalQuestionDeck = shuffle([...questionBank]);

        try {
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                await signInWithCustomToken(auth, __initial_auth_token);
            } else {
                await signInAnonymously(auth);
            }
        } catch (e) {
            console.error(e);
            alert("ì ‘ì† ì˜¤ë¥˜. Firebase ì„¤ì •ì´ í•„ìš”í•©ë‹ˆë‹¤.");
        }
    };

    onAuthStateChanged(auth, (user) => {
        if (user) {
            currentUser = user;
            myPlayerId = user.uid;
            document.getElementById('login-screen').style.display = 'none';
            setupMultiplayer();
            loadStage(1);
            startGameLoop();
        }
    });

    // --- Multiplayer Logic ---
    function setupMultiplayer() {
        const playersRef = collection(db, 'artifacts', appId, 'public', 'data', 'players');
        const myRef = doc(playersRef, myPlayerId);

        setInterval(async () => {
            if (gameState !== 'PLAYING') return;
            try {
                await setDoc(myRef, {
                    x: Math.round(player.x),
                    y: Math.round(player.y),
                    stage: stage,
                    nickname: nickname,
                    facing: player.facing,
                    lastUpdate: serverTimestamp()
                });
            } catch (e) { console.warn("Sync error", e); }
        }, 100); 

        onSnapshot(playersRef, (snapshot) => {
            snapshot.docChanges().forEach((change) => {
                const data = change.doc.data();
                if (change.doc.id === myPlayerId) return;
                
                if (change.type === "added" || change.type === "modified") {
                    if(data.stage === stage) {
                        otherPlayers[change.doc.id] = data;
                    } else {
                        delete otherPlayers[change.doc.id];
                    }
                }
                if (change.type === "removed") {
                    delete otherPlayers[change.doc.id];
                }
            });
        });
    }

    // --- Game Logic ---
    function loadStage(lvl) {
        stage = lvl;
        gameState = 'PLAYING';
        collectedHints = [];
        player.x = 100; player.y = 200;
        player.vx = 0; player.vy = 0;
        player.invulnerable = 120; 
        
        const currentLayout = stageLayouts[stage];
        document.getElementById('stage-display').innerText = stage;
        document.getElementById('stage-name').innerText = currentLayout.name;
        document.getElementById('gameover-screen').style.display = 'none';
        updateHintUI();
        updateLives();

        generateMap(lvl);

        const words = wordBank[lvl];
        currentPassword = words[Math.floor(Math.random() * words.length)];

        const spots = currentLayout.puzzleSpots;
        
        let startIndex = 0;
        if (lvl === 2) startIndex = 4;
        if (lvl === 3) startIndex = 9;

        puzzles = spots.map((spot, index) => {
            const deckIndex = (startIndex + index) % globalQuestionDeck.length;
            const qData = globalQuestionDeck[deckIndex];
            
            return {
                ...spot,
                q: qData.q,
                options: qData.options,
                a: qData.a,
                hint: currentPassword[index] || "?", 
                solved: false
            };
        });
        
        // --- Enhanced Monster Generation ---
        monsters = [];
        const monsterCount = 5 + lvl * 2;
        const width = map[0].length * TILE_SIZE;

        for(let i=0; i<monsterCount; i++) {
            const type = Math.random() > 0.5 ? 'fly' : 'crawl';
            const m = {
                x: 400 + Math.random() * (width - 600),
                y: type === 'fly' ? 100 + Math.random() * 200 : 0, 
                w: 40, h: 40,
                vx: 2, vy: 0,
                type: type,
                attackTimer: 100 + Math.random() * 300, 
                isAttacking: false,
                attackDuration: 0,
                patrolStart: 0, patrolEnd: width
            };
            monsters.push(m);
        }

        showMessage(`STAGE ${lvl} ì‹œì‘!\níŒíŠ¸ë¥¼ ëª¨ì•„ ì•”í˜¸ë¥¼ í•´ë…í•˜ì„¸ìš”.`);
    }
    
    window.retryStage = () => {
        lives = 5;
        loadStage(stage);
    }

    // --- Dynamic Map Generation per Stage ---
    function generateMap(lvl) {
        map = [];
        const width = 60; 
        const height = 13;
        
        for(let y=0; y<height; y++) {
            let row = [];
            for(let x=0; x<width; x++) {
                if(y === height-1) row.push(1); 
                else if(x===0 || x===width-1) row.push(1); 
                else row.push(0);
            }
            map.push(row);
        }

        if (lvl === 1) {
            addPlatform(5, 9, 4);
            addPlatform(12, 7, 5);
            addPlatform(20, 10, 3);
            addPlatform(25, 6, 6);
            addPlatform(35, 8, 5);
            addPlatform(42, 5, 4);
            addPlatform(50, 9, 3);
        } 
        else if (lvl === 2) {
            for(let x=15; x<20; x++) map[height-1][x] = 0; // Pit
            for(let x=35; x<40; x++) map[height-1][x] = 0; // Pit
            addPlatform(8, 8, 3);
            addPlatform(15, 6, 3);
            addPlatform(22, 9, 4);
            addPlatform(28, 5, 4);
            addPlatform(36, 6, 3);
            addPlatform(45, 8, 5);
            addPlatform(52, 5, 3);
        } 
        else if (lvl === 3) {
            for(let x=10; x<50; x++) if(x%5 !== 0) map[height-1][x] = 0; 
            addPlatform(5, 10, 2);
            addPlatform(10, 8, 2);
            addPlatform(15, 6, 2);
            addPlatform(20, 4, 2);
            addPlatform(25, 7, 2);
            addPlatform(30, 10, 2);
            addPlatform(35, 5, 2);
            addPlatform(40, 8, 2);
            addPlatform(45, 4, 2);
            addPlatform(50, 7, 2);
        }

        map[height-2][width-3] = 9;
        map[height-3][width-3] = 9;

        function addPlatform(x, y, w) {
            for(let i=0; i<w; i++) if(x+i < width-1) map[y][x+i] = 1;
        }
    }

    function startGameLoop() {
        requestAnimationFrame(gameLoop);
    }

    function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop);
    }

    function update() {
        if(gameState !== 'PLAYING') return;

        const keys = window.keys || {};
        if (keys['ArrowLeft']) { player.vx = -SPEED; player.facing = -1; }
        else if (keys['ArrowRight']) { player.vx = SPEED; player.facing = 1; }
        else { player.vx = 0; }

        if (keys['ArrowUp'] && player.grounded) {
            player.vy = JUMP_FORCE;
            player.grounded = false;
        }

        if (keys['Space']) checkInteraction();

        player.vy += GRAVITY;
        player.x += player.vx;
        checkCollision(player, 'x');
        player.y += player.vy;
        player.grounded = false;
        checkCollision(player, 'y');
        
        checkPlayerCollision();

        if (player.invulnerable > 0) player.invulnerable--;

        if(player.y > 800) { 
            takeDamage("ì¶”ë½í–ˆìŠµë‹ˆë‹¤!");
            player.x = 100; player.y = 200; player.vy = 0;
        }

        monsters.forEach(m => {
            m.x += m.vx;
            if(Math.random() < 0.01) m.vx *= -1;
            
            if (m.type === 'crawl') {
                m.vy += GRAVITY;
                m.y += m.vy;
                const left = Math.floor(m.x / TILE_SIZE);
                const right = Math.floor((m.x + m.w) / TILE_SIZE);
                const bottom = Math.floor((m.y + m.h) / TILE_SIZE);
                const top = Math.floor(m.y / TILE_SIZE);
                if (m.vy > 0 && (isSolid(left, bottom) || isSolid(right, bottom))) {
                    m.y = bottom * TILE_SIZE - m.h;
                    m.vy = 0;
                }
                const wallSide = m.vx > 0 ? right : left;
                if (isSolid(wallSide, Math.floor((m.y + m.h/2)/TILE_SIZE))) {
                    m.vx *= -1;
                }
            } else {
                if (m.x < 0 || m.x > map[0].length * TILE_SIZE) m.vx *= -1;
            }

            if (m.isAttacking) {
                m.attackDuration--;
                if (m.attackDuration <= 0) {
                    m.isAttacking = false;
                    m.attackTimer = 200 + Math.random() * 300; 
                }
                
                const dist = Math.hypot((player.x + 20) - (m.x + 20), (player.y + 20) - (m.y + 20));
                if (dist < 100) { 
                    takeDamage("ê°€ì‹œì— ì°”ë ¸ìŠµë‹ˆë‹¤!");
                    player.vx = (player.x < m.x) ? -15 : 15;
                    player.vy = -10;
                }
            } else {
                m.attackTimer--;
                if (m.attackTimer <= 0) {
                    m.isAttacking = true;
                    m.attackDuration = 30; 
                    if (Math.hypot(player.x - m.x, player.y - m.y) < 400) {
                        cameraX += (Math.random() - 0.5) * 10; 
                    }
                }

                if(Math.abs(player.x - m.x) < 30 && Math.abs(player.y - m.y) < 30) {
                    takeDamage("ê´´ë¬¼ì—ê²Œ ë‹¿ì•˜ìŠµë‹ˆë‹¤!");
                    player.vy = -10;
                    player.vx = (player.x < m.x) ? -10 : 10;
                }
            }
        });

        cameraX += (player.x - canvas.width/2 - cameraX) * 0.1;
        const maxCam = map[0].length * TILE_SIZE - canvas.width;
        cameraX = Math.max(0, Math.min(cameraX, maxCam));
    }

    function takeDamage(msg) {
        if (player.invulnerable > 0) return; 

        lives--;
        updateLives();
        player.invulnerable = 120; 
        showMessage(msg);
        
        if(lives <= 0) {
            gameState = 'GAMEOVER';
            document.getElementById('gameover-screen').style.display = 'flex';
        }
    }

    function checkCollision(ent, axis) {
        const left = Math.floor(ent.x / TILE_SIZE);
        const right = Math.floor((ent.x + ent.w - 1) / TILE_SIZE);
        const top = Math.floor(ent.y / TILE_SIZE);
        const bottom = Math.floor((ent.y + ent.h - 1) / TILE_SIZE);

        if (axis === 'x') {
            if (isSolid(left, top) || isSolid(right, top) || 
                isSolid(left, bottom) || isSolid(right, bottom)) {
                ent.x -= ent.vx;
            }
        } else {
            if (ent.vy > 0 && (isSolid(left, bottom) || isSolid(right, bottom))) {
                ent.y = bottom * TILE_SIZE - ent.h;
                ent.vy = 0;
                ent.grounded = true;
            } else if (ent.vy < 0 && (isSolid(left, top) || isSolid(right, top))) {
                ent.y = (top + 1) * TILE_SIZE;
                ent.vy = 0;
            }
        }
    }

    function checkPlayerCollision() {
        for (const pid in otherPlayers) {
            const other = otherPlayers[pid];
            if (player.x < other.x + 40 && player.x + 40 > other.x &&
                player.y + 40 > other.y && player.y < other.y + 40) {
                
                if (player.vy >= 0 && (player.y + 40) <= (other.y + 20)) {
                    player.y = other.y - 40; 
                    player.vy = 0;
                    player.grounded = true;
                }
            }
        }
    }

    function isSolid(x, y) {
        if(y < 0 || y >= map.length || x < 0 || x >= map[0].length) return false;
        return map[y][x] === 1;
    }

    function checkInteraction() {
        const gateX = (map[0].length - 3) * TILE_SIZE;
        if (Math.abs(player.x - gateX) < 100) {
            document.getElementById('gate-modal').style.display = 'block';
            gameState = 'MODAL';
            return;
        }

        let target = null;
        for(let p of puzzles) {
            if(p.solved) continue;
            if(Math.abs(player.x - p.x) < 60 && Math.abs(player.y - p.y) < 60) {
                target = p;
                break;
            }
        }
        if(target) openQuiz(target);
    }

    window.openQuiz = (q) => {
        gameState = 'QUIZ';
        document.getElementById('quiz-modal').style.display = 'block';
        document.getElementById('quiz-content').innerText = q.q;
        const opts = document.getElementById('quiz-options');
        opts.innerHTML = '';
        q.options.forEach((o, i) => {
            const btn = document.createElement('button');
            btn.className = 'option-btn';
            btn.innerText = `${i+1}. ${o}`;
            btn.onclick = () => answerQuiz(q, i);
            opts.appendChild(btn);
        });
    };

    window.answerQuiz = (q, idx) => {
        document.getElementById('quiz-modal').style.display = 'none';
        if(idx === q.a) {
            q.solved = true;
            collectedHints.push(q.hint);
            updateHintUI();
            showMessage(`ì •ë‹µ! íŒíŠ¸ '${q.hint}' íšë“!`);
        } else {
            takeDamage("ì˜¤ë‹µì…ë‹ˆë‹¤! ìƒëª…ì´ ì¤„ì–´ë“­ë‹ˆë‹¤.");
        }
        gameState = 'PLAYING';
    };

    window.checkGatePassword = () => {
        const input = document.getElementById('gate-password').value.toUpperCase().trim();
        const correct = currentPassword;
        
        if(input === correct) {
            document.getElementById('gate-modal').style.display = 'none';
            if(stage === 3) {
                alert("ì¶•í•˜í•©ë‹ˆë‹¤! ì„±ì„ ì™„ì „íˆ íƒˆì¶œí–ˆìŠµë‹ˆë‹¤!");
                location.reload();
            } else {
                showMessage("ë¬¸ì´ ì—´ë ¸ìŠµë‹ˆë‹¤! ë‹¤ìŒ ì¸µìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.");
                setTimeout(() => loadStage(stage + 1), 2000);
            }
        } else {
            alert("ë¹„ë°€ë²ˆí˜¸ê°€ í‹€ë ¸ìŠµë‹ˆë‹¤.");
            takeDamage("ì˜ëª»ëœ ì•”í˜¸ì…ë‹ˆë‹¤!");
            document.getElementById('gate-modal').style.display = 'none';
            gameState = 'PLAYING';
        }
    };

    window.closeGateModal = () => {
        document.getElementById('gate-modal').style.display = 'none';
        gameState = 'PLAYING';
    };

    function updateHintUI() {
        document.getElementById('hint-text').innerText = collectedHints.join(" - ") || "ì—†ìŒ";
    }

    function updateLives() {
        let h = "";
        for(let i=0; i<lives; i++) h += "â¤";
        for(let i=lives; i<5; i++) h += "ğŸ–¤";
        document.getElementById('lives-display').innerText = h;
    }

    function showMessage(txt) {
        const el = document.getElementById('message-overlay');
        el.innerText = txt;
        el.style.display = 'block';
        setTimeout(() => el.style.display = 'none', 2000);
    }

    function safeDrawImage(ctx, img, x, y, w, h, fallbackColor = '#555') {
        if (img && img.complete && img.naturalWidth !== 0) {
            try {
                ctx.drawImage(img, x, y, w, h);
            } catch (e) {
                drawFallback(ctx, x, y, w, h, fallbackColor);
            }
        } else {
            drawFallback(ctx, x, y, w, h, fallbackColor);
        }
    }

    function drawFallback(ctx, x, y, w, h, color) {
        ctx.fillStyle = color;
        ctx.fillRect(x, y, w, h);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, w, h);
    }

    function draw() {
        const currentLayout = stageLayouts[stage];
        const bg = currentLayout ? currentLayout.bg : null;

        if (bg && bg.complete && bg.naturalWidth !== 0) {
            ctx.drawImage(bg, 0, 0, canvas.width, canvas.height);
        } else {
            ctx.fillStyle = '#110505';
            ctx.fillRect(0,0,canvas.width, canvas.height);
        }
        
        ctx.fillStyle = 'rgba(20, 0, 0, 0.5)';
        ctx.fillRect(0,0,canvas.width, canvas.height);

        ctx.save();
        ctx.translate(-Math.floor(cameraX), 0);

        const width = map[0].length;
        const height = map.length;
        const startX = Math.floor(cameraX / TILE_SIZE);
        const endX = startX + (canvas.width / TILE_SIZE) + 2;

        for(let y=0; y<height; y++) {
            for(let x=startX; x<=endX; x++) {
                if(x < 0 || x >= width) continue;
                const tile = map[y][x];
                if(tile === 1) {
                    ctx.fillStyle = '#2b0a0a';
                    ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    ctx.strokeStyle = '#551111';
                    ctx.strokeRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                } else if (tile === 9) {
                    ctx.fillStyle = 'black';
                    ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE*2);
                    ctx.font = '30px Arial';
                    ctx.fillStyle = 'red';
                    ctx.fillText('ğŸ”’', x*TILE_SIZE+10, y*TILE_SIZE+40);
                }
            }
        }

        puzzles.forEach(p => {
            if(p.solved) return;
            const img = assets.items[p.type] || assets.items.book;
            const bounce = Math.sin(Date.now() / 300) * 5;
            safeDrawImage(ctx, img, p.x, p.y + bounce, 40, 40, 'gold');

            if(Math.abs(player.x - p.x) < 60 && Math.abs(player.y - p.y) < 60) {
                ctx.fillStyle = 'white';
                ctx.font = '14px sans-serif';
                ctx.fillText("SPACE", p.x, p.y - 10);
            }
        });

        monsters.forEach(m => {
            ctx.save();
            let filterColor = null;
            if (m.isAttacking) {
                ctx.beginPath();
                ctx.arc(m.x + m.w/2, m.y + m.h/2, 100, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 0, 0, 0.4)'; 
                ctx.fill();
                
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 4;
                for(let i=0; i<8; i++) {
                    const angle = (Date.now() / 100) + (i * Math.PI / 4);
                    const cx = m.x + m.w/2;
                    const cy = m.y + m.h/2;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(cx + Math.cos(angle) * 100, cy + Math.sin(angle) * 100);
                    ctx.stroke();
                }
                filterColor = 'red';
            } else if (m.attackTimer < 60) {
                const shake = (Math.random() - 0.5) * 5;
                ctx.translate(shake, shake);
                filterColor = 'orange';
                
                ctx.fillStyle = 'red';
                ctx.font = '20px sans-serif';
                ctx.fillText("!!!", m.x+m.w/2, m.y - 10);
            }

            const mImg = m.type === 'fly' ? assets.monsterFly : assets.monsterCrawl;

            if(m.vx > 0) {
                 ctx.translate(m.x + m.w, m.y);
                 ctx.scale(-1, 1);
                 safeDrawImage(ctx, mImg, 0, 0, m.w, m.h, filterColor || 'green');
            } else {
                 safeDrawImage(ctx, mImg, m.x, m.y, m.w, m.h, filterColor || 'green');
            }
            ctx.restore();
        });

        Object.values(otherPlayers).forEach(p => {
            ctx.globalAlpha = 0.8;
            drawAvatar(p.x, p.y, p.facing, assets.player, p.nickname, false);
            ctx.globalAlpha = 1.0;
        });

        if (player.invulnerable <= 0 || Math.floor(Date.now() / 100) % 2 === 0) {
            drawAvatar(player.x, player.y, player.facing, assets.player, nickname, true);
        }

        ctx.restore();
    }

    function drawAvatar(x, y, facing, imgObj, name, isMe) {
        ctx.save();
        ctx.font = 'bold 12px "Nanum Gothic"';
        ctx.fillStyle = isMe ? '#ffff00' : 'white';
        ctx.textAlign = 'center';
        ctx.fillText(name, x + 20, y - 10);

        if(facing === -1) {
            ctx.translate(x + 40, y);
            ctx.scale(-1, 1);
            safeDrawImage(ctx, imgObj, 0, 0, 40, 40, 'blue');
        } else {
            safeDrawImage(ctx, imgObj, x, y, 40, 40, 'blue');
        }
        ctx.restore();
    }

    window.keys = {};
    window.addEventListener('keydown', e => window.keys[e.code] = true);
    window.addEventListener('keyup', e => window.keys[e.code] = false);

</script>
</body>
</html>