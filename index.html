<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shadow School: 6학년의 악몽 (Updated)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; user-select: none; }
        
        /* UI 레이어 */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        /* 십자선 */
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 8px; height: 8px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 4px white;
        }

        /* 상태 표시줄 */
        #hud {
            position: absolute; top: 20px; left: 20px;
            color: #ff3333; font-size: 1.5rem; font-weight: bold;
            text-shadow: 2px 2px 0 #000;
        }
        #timer-box {
            position: absolute; top: 20px; right: 20px;
            color: #fff; font-size: 2rem; font-weight: bold;
            text-shadow: 0 0 10px red;
        }

        /* 상호작용 텍스트 */
        #interact-msg {
            position: absolute; top: 60%; left: 50%; transform: translate(-50%, -50%);
            color: #fff; font-size: 1.2rem; display: none; text-shadow: 1px 1px 2px black;
        }

        /* 퀴즈 모달 */
        #quiz-modal {
            display: none; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 10, 5, 0.95);
            border: 4px solid #3e2723;
            padding: 20px; width: 400px;
            color: #d7ccc8; pointer-events: auto;
            text-align: center;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
        }
        #quiz-modal h2 { margin-top: 0; color: #ff5555; border-bottom: 1px solid #5d4037; padding-bottom: 10px; }
        .quiz-btn {
            display: block; width: 100%; padding: 10px; margin: 5px 0;
            background: #3e2723; color: #d7ccc8; border: 1px solid #5d4037;
            cursor: pointer; text-align: left; font-weight: bold;
        }
        .quiz-btn:hover { background: #5d4037; color: #fff; }

        /* 시작 화면 */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #050505; color: #a00;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 100; pointer-events: auto;
            background-image: repeating-linear-gradient(0deg, transparent, transparent 1px, #110000 1px, #110000 2px);
        }
        h1 { font-size: 4rem; text-shadow: 0 0 20px red; margin-bottom: 10px; font-weight: 900; }
        .btn-start {
            padding: 15px 40px; font-size: 2rem;
            background: #200; color: #f00; border: 2px solid #f00;
            cursor: pointer; margin-top: 20px;
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold;
        }
        .btn-start:hover { background: #500; color: #fff; box-shadow: 0 0 20px red; }

        /* 게임 오버 화면 */
        #gameover-screen {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(20, 0, 0, 0.95); z-index: 200; pointer-events: auto;
            flex-direction: column; justify-content: center; align-items: center;
            color: white; text-align: center;
        }
        #gameover-msg { font-size: 5rem; color: red; font-family: 'Chiller', serif; text-shadow: 0 0 30px black; }
        
        .btn-group { display: flex; gap: 20px; margin-top: 30px; }
        .btn-retry { padding: 15px 30px; font-size: 1.5rem; background: #004400; color: #0f0; border: 2px solid #0f0; cursor: pointer; }
        .btn-giveup { padding: 15px 30px; font-size: 1.5rem; background: #440000; color: #f00; border: 2px solid #f00; cursor: pointer; }
        .btn-retry:hover { background: #006600; color: #fff; }
        .btn-giveup:hover { background: #660000; color: #fff; }

        /* 비네트 & 노이즈 */
        .vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 40%, black 140%);
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="vignette"></div>
        <div id="crosshair"></div>
        <div id="hud">
            교실: <span id="room-name">대기실</span><br>
            힌트: <span id="hint-count">0</span> / 5
        </div>
        <div id="timer-box">05:00</div>
        <div id="interact-msg">[클릭] 조사하기</div>
    </div>

    <div id="quiz-modal">
        <h2 id="quiz-subject">문제</h2>
        <p id="quiz-text" style="font-size:1.1rem; margin-bottom:20px;"></p>
        <div id="quiz-options"></div>
        <p style="color:#a1887f; font-size:0.8rem; margin-top:10px;">⚠️ 문제를 푸는 동안에도 '그것'은 다가옵니다...</p>
    </div>

    <div id="start-screen">
        <h1>SHADOW SCHOOL</h1>
        <p style="color:#ccc; font-size:1.2rem;">6학년 2학기의 악몽에서 탈출하라</p>
        <p>나무 바닥이 삐걱거리는 소리가 들립니다...</p>
        <p style="color:red; font-weight:bold;">검은 형체의 '붉은 가시'를 조심하세요.</p>
        <button class="btn-start" id="btn-init">입장하기</button>
    </div>

    <div id="gameover-screen">
        <div id="gameover-msg">GAME OVER</div>
        <p id="death-reason" style="font-size:1.5rem;">...</p>
        <div class="btn-group">
            <button class="btn-retry" onclick="restartGame(false)">다시 시도</button>
            <button class="btn-giveup" onclick="restartGame(true)">포기하기 (지옥)</button>
        </div>
    </div>

    <!-- Import Maps -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import * as CANNON from 'cannon-es';

        // --- 텍스처 생성기 (나무, 곰팡이) ---
        function createWoodTexture(isDark = false) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // 베이스 색상
            ctx.fillStyle = isDark ? '#3e2723' : '#5d4037';
            ctx.fillRect(0, 0, 512, 512);
            
            // 나무결 노이즈
            for (let i = 0; i < 2000; i++) {
                ctx.fillStyle = isDark ? 'rgba(0,0,0,0.1)' : 'rgba(0,0,0,0.05)';
                ctx.fillRect(Math.random() * 512, 0, Math.random() * 2 + 1, 512); // 세로 줄무늬
            }
            // 옹이
            for (let i = 0; i < 20; i++) {
                ctx.beginPath();
                ctx.arc(Math.random() * 512, Math.random() * 512, Math.random() * 10 + 5, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.fill();
            }
            if (isDark) { // 곰팡이/거미줄 효과
                for(let i=0; i<500; i++) {
                    ctx.fillStyle = 'rgba(20, 20, 20, 0.3)';
                    const x = Math.random() * 512;
                    const y = Math.random() * 512;
                    ctx.beginPath(); ctx.arc(x, y, Math.random() * 5, 0, Math.PI*2); ctx.fill();
                }
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        const woodTexture = createWoodTexture(false);
        const ceilingTexture = createWoodTexture(true);

        // --- 게임 데이터 ---
        const subjects = ["국어", "수학", "사회", "과학", "영어"];
        let currentSubjectIndex = 0;
        let roomOrder = [];

        // 문제 데이터 생략 (위와 동일하지만 공간 절약을 위해 포함)
        const quizData = {
            "국어": [
                { q: "글쓴이의 주장을 뒷받침하는 자료는?", o: ["근거", "결론", "예시", "비유"], a: 0 },
                { q: "'발이 넓다'의 뜻은?", o: ["발이 크다", "아는 사람이 많다", "빨리 걷는다", "신발이 크다"], a: 1 },
                { q: "사건을 이끌어가는 주체는?", o: ["배경", "인물", "소재", "주제"], a: 1 },
                { q: "영화 감상 후 쓰는 글은?", o: ["기행문", "설명문", "감상문", "논설문"], a: 2 },
                { q: "뉴스의 기능이 아닌 것은?", o: ["정보 전달", "여론 형성", "상품 판매", "사회 감시"], a: 2 }
            ],
            "수학": [
                { q: "원주율 기호는?", o: ["π", "θ", "λ", "Σ"], a: 0 },
                { q: "지름 10cm 원의 원주는? (π=3.14)", o: ["31.4cm", "15.7cm", "314cm", "100cm"], a: 0 },
                { q: "비례식 2:3 = 4:□. □는?", o: ["5", "6", "7", "8"], a: 1 },
                { q: "원기둥 부피 식?", o: ["밑넓이×높이", "밑넓이+높이", "한변×한변", "가로×세로"], a: 0 },
                { q: "쌓기나무 위,앞,옆 보면 개수 안다.", o: ["O", "X"], a: 0 }
            ],
            "사회": [
                { q: "법을 만드는 기관?", o: ["국회", "정부", "법원", "경찰서"], a: 0 },
                { q: "지구본을 평면에 나타낸 것?", o: ["지구본", "세계 지도", "위성 사진", "내비"], a: 1 },
                { q: "6.25 전쟁 발발 연도?", o: ["1945", "1950", "1960", "1919"], a: 1 },
                { q: "우리나라 경제 성장 특징?", o: ["수입 중심", "농업 중심", "수출 중심", "폐쇄 경제"], a: 2 },
                { q: "권리 보호 최후의 보루?", o: ["법원", "학교", "은행", "마트"], a: 0 }
            ],
            "과학": [
                { q: "전기가 흐르는 물질?", o: ["도체", "부도체", "반도체", "유전체"], a: 0 },
                { q: "연소의 3요소 아님?", o: ["산소", "탈 물질", "발화점 이상 온도", "이산화탄소"], a: 3 },
                { q: "계절 변화 이유?", o: ["자전", "공전", "모양", "중력"], a: 1 },
                { q: "소화 기관?", o: ["심장", "위", "폐", "뇌"], a: 1 },
                { q: "낮과 밤 이유?", o: ["지구 자전", "지구 공전", "달의 공전", "태양 이동"], a: 0 }
            ],
            "영어": [
                { q: "Museum?", o: ["도서관", "박물관", "학교", "병원"], a: 1 },
                { q: "미래 조동사?", o: ["Will", "Did", "Do", "Can"], a: 0 },
                { q: "What did you do?", o: ["내일 뭐해?", "어제 뭐했니?", "지금 뭐해?", "누구니?"], a: 1 },
                { q: "Toothache?", o: ["두통", "치통", "감기", "열"], a: 1 },
                { q: "12월?", o: ["December", "November", "October", "January"], a: 0 }
            ]
        };

        // --- 오디오 시스템 ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let bgmInterval;
        
        function playTone(freq, type, duration, vol = 0.1) {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(vol, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        function playBGM() {
            if(bgmInterval) clearInterval(bgmInterval);
            
            if (isHardMode) {
                bgmInterval = setInterval(() => {
                    if(gameState !== 'PLAYING') return;
                    const notes = [100, 110, 120, 200, 210, 220]; 
                    playTone(notes[Math.floor(Math.random() * notes.length)], 'sawtooth', 0.5, 0.2);
                    if(Math.random() < 0.3) playTone(Math.random()*800, 'square', 0.1, 0.05); 
                }, 300);
            } else {
                bgmInterval = setInterval(() => {
                    if(gameState !== 'PLAYING') return;
                    const notes = [523, 587, 659, 698, 783, 880, 987];
                    playTone(notes[Math.floor(Math.random() * notes.length)], 'sine', 1.5, 0.1);
                    if(Math.random() < 0.1) playTone(notes[0]-100, 'sawtooth', 2.0, 0.05);
                }, 800);
            }
        }

        function playScream() {
            playTone(800, 'sawtooth', 0.5, 0.5);
            setTimeout(() => playTone(700, 'sawtooth', 0.5, 0.5), 100);
            setTimeout(() => playTone(600, 'sawtooth', 1.0, 0.5), 200);
        }

        function playSpikeSound() {
            playTone(400, 'square', 0.1, 0.3);
            playTone(300, 'square', 0.1, 0.3);
        }

        // --- 전역 변수 ---
        let scene, camera, renderer, world;
        let controls;
        let playerBody, enemyBody;
        let gameState = 'START';
        let hintsCollected = 0;
        let timer = 300; 
        let quizBoxes = [];
        let doorMesh = null;
        let currentRoomQuizDeck = [];
        let activeQuizBox = null;
        let isHardMode = false;
        
        // 속도 상향
        let playerSpeed = 25.0; // 기존 10 -> 25
        let enemySpeed = 12.0;  // 기존 3.5 -> 12 (하드모드 18)

        let enemyMesh;
        let spikes = []; // 가시 객체 배열

        const raycaster = new THREE.Raycaster();
        const center = new THREE.Vector2(0, 0);

        // --- 초기화 ---
        const startBtn = document.getElementById('btn-init');
        startBtn.addEventListener('click', () => {
            document.getElementById('start-screen').style.display = 'none';
            initGame();
        });

        window.restartGame = (hardMode) => {
            document.getElementById('gameover-screen').style.display = 'none';
            isHardMode = hardMode;
            
            if(isHardMode) {
                enemySpeed = 18.0; 
                timer = 200; 
            } else {
                enemySpeed = 12.0;
                timer = 300;
            }

            while(scene.children.length > 0){ scene.remove(scene.children[0]); }
            world.bodies = [];
            initGame();
        };

        function shuffle(array) { return array.sort(() => Math.random() - 0.5); }

        function initGame() {
            roomOrder = shuffle([...subjects]);
            currentSubjectIndex = 0;
            hintsCollected = 0;
            document.getElementById('hint-count').innerText = "0";
            
            initThree();
            initPhysics();
            loadRoom(roomOrder[currentSubjectIndex]);
            
            gameState = 'PLAYING';
            playBGM();
            animate();
            
            if(window.gameTimer) clearInterval(window.gameTimer);
            window.gameTimer = setInterval(() => {
                if(gameState === 'PLAYING') {
                    timer--;
                    const m = Math.floor(timer / 60).toString().padStart(2, '0');
                    const s = (timer % 60).toString().padStart(2, '0');
                    document.getElementById('timer-box').innerText = `${m}:${s}`;
                    if(timer <= 0) gameOver("시간이 초과되었습니다...");
                }
            }, 1000);
        }

        function initThree() {
            scene = new THREE.Scene();
            
            if (isHardMode) {
                scene.background = new THREE.Color(0x000000); 
                scene.fog = new THREE.FogExp2(0x220000, 0.05); 
            } else {
                scene.background = new THREE.Color(0x100505); 
                scene.fog = new THREE.FogExp2(0x100505, 0.025); 
            }

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            
            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            if (document.querySelector('canvas')) document.body.removeChild(document.querySelector('canvas'));
            document.body.appendChild(renderer.domElement);

            // 손전등
            const flashlight = new THREE.SpotLight(0xffffff, isHardMode ? 2.5 : 4); 
            flashlight.angle = Math.PI / 2.5; 
            flashlight.penumbra = 0.5;
            flashlight.decay = 1; 
            flashlight.distance = isHardMode ? 30 : 80; 
            flashlight.castShadow = true;
            camera.add(flashlight);
            flashlight.target = camera; 
            scene.add(camera);

            // 전체 조명 (방 밝게)
            const ambient = new THREE.AmbientLight(0xffaa88, isHardMode ? 0.3 : 0.8);
            scene.add(ambient);
        }

        function initPhysics() {
            world = new CANNON.World();
            world.gravity.set(0, -30, 0); // 중력 더 강화 (빠른 게임플레이)
            
            const defMat = new CANNON.Material();
            const contact = new CANNON.ContactMaterial(defMat, defMat, { friction: 0.0, restitution: 0.0 });
            world.addContactMaterial(contact);

            const shape = new CANNON.Sphere(1.5); 
            playerBody = new CANNON.Body({ mass: 70, shape: shape, material: defMat, fixedRotation: true, linearDamping: 0.9 });
            playerBody.position.set(0, 5, 0);
            world.addBody(playerBody);

            playerBody.addEventListener('collide', (e) => {
                const normal = new CANNON.Vec3();
                e.contact.ni.negate(normal);
                if(normal.dot(new CANNON.Vec3(0,1,0)) > 0.5) canJump = true;
            });

            // 적 (검은 형체)
            const eShape = new CANNON.Cylinder(1, 1, 3, 8);
            enemyBody = new CANNON.Body({ mass: 100, shape: eShape, material: defMat, fixedRotation: true, linearDamping: 0.9 });
            enemyBody.position.set(0, -100, 0); 
            world.addBody(enemyBody);

            // 적 그래픽
            const eGeo = new THREE.CapsuleGeometry(1, 3, 4, 8);
            const eMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.1 }); // 더 검고 매끄럽게
            enemyMesh = new THREE.Mesh(eGeo, eMat);
            
            const eyeGeo = new THREE.SphereGeometry(0.3);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const eye1 = new THREE.Mesh(eyeGeo, eyeMat);
            eye1.position.set(-0.4, 1, 0.8);
            const eye2 = new THREE.Mesh(eyeGeo, eyeMat);
            eye2.position.set(0.4, 1, 0.8);
            enemyMesh.add(eye1);
            enemyMesh.add(eye2);
            
            scene.add(enemyMesh);

            controls = new PointerLockControls(camera, document.body);
            
            document.body.addEventListener('click', () => {
                const modal = document.getElementById('quiz-modal');
                const goScreen = document.getElementById('gameover-screen');
                const startScreen = document.getElementById('start-screen');
                
                if(gameState === 'PLAYING' && modal.style.display !== 'block' && goScreen.style.display !== 'flex' && startScreen.style.display !== 'flex') {
                    controls.lock();
                    checkInteraction(true);
                }
            });
        }

        function loadRoom(subjectName) {
            document.getElementById('room-name').innerText = subjectName + (isHardMode ? " (지옥)" : "");
            document.getElementById('hint-count').innerText = "0";
            hintsCollected = 0;
            
            currentRoomQuizDeck = shuffle([...quizData[subjectName]]);
            quizBoxes = [];
            spikes = []; // 가시 초기화

            playerBody.position.set(0, 5, 0);
            playerBody.velocity.set(0,0,0);
            
            enemyBody.position.set(40, 5, 40);
            enemyBody.velocity.set(0,0,0);

            createEnvironment();
        }

        function createEnvironment() {
            // 바닥 (목재 텍스처 적용)
            woodTexture.repeat.set(20, 20);
            const floorGeo = new THREE.PlaneGeometry(100, 100);
            const floorMat = new THREE.MeshStandardMaterial({ map: woodTexture });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);
            
            // 천장 (곰팡이 핀 목재)
            ceilingTexture.repeat.set(10, 10);
            const ceilGeo = new THREE.PlaneGeometry(100, 100);
            const ceilMat = new THREE.MeshStandardMaterial({ map: ceilingTexture, color: 0x888888 });
            const ceil = new THREE.Mesh(ceilGeo, ceilMat);
            ceil.rotation.x = Math.PI / 2;
            ceil.position.y = 15; // 높이
            scene.add(ceil);

            const floorBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane() });
            floorBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
            world.addBody(floorBody);

            // 벽 (목재)
            for(let i=0; i<40; i++) { // 벽 개수 증가
                const x = (Math.random()-0.5) * 80;
                const z = (Math.random()-0.5) * 80;
                if(Math.abs(x) < 5 && Math.abs(z) < 5) continue;
                createBox(x, 7.5, z, 3, 15, 3, 0x5d4037, true, true); // 텍스처 적용
            }

            // 퀴즈 박스
            for(let i=0; i<8; i++) {
                const x = (Math.random()-0.5) * 60;
                const z = (Math.random()-0.5) * 60;
                if(Math.abs(x) < 10 && Math.abs(z) < 10) continue;
                
                const mesh = createBox(x, 2, z, 1.5, 1.5, 1.5, 0xffd700, false, false);
                mesh.material.emissive = new THREE.Color(0x333300);
                mesh.userData = { type: 'quiz', id: i };
                quizBoxes.push(mesh);
            }

            // 문
            const doorGeo = new THREE.BoxGeometry(8, 10, 1);
            const doorMat = new THREE.MeshStandardMaterial({ color: 0x3e2723 });
            doorMesh = new THREE.Mesh(doorGeo, doorMat);
            doorMesh.position.set(0, 5, -45);
            doorMesh.userData = { type: 'door' };
            scene.add(doorMesh);
            
            const doorBody = new CANNON.Body({ mass: 0, shape: new CANNON.Box(new CANNON.Vec3(4, 5, 0.5)) });
            doorBody.position.set(0, 5, -45);
            world.addBody(doorBody);
        }

        function createBox(x, y, z, w, h, d, color, isStatic, useTexture) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const mat = new THREE.MeshStandardMaterial({ 
                color: color, 
                map: useTexture ? woodTexture : null 
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            const body = new CANNON.Body({
                mass: isStatic ? 0 : 1,
                shape: new CANNON.Box(new CANNON.Vec3(w/2, h/2, d/2)),
                position: new CANNON.Vec3(x, y, z)
            });
            world.addBody(body);
            return mesh;
        }

        const keyState = {};
        let canJump = false;
        document.addEventListener('keydown', (e) => keyState[e.code] = true);
        document.addEventListener('keyup', (e) => keyState[e.code] = false);

        function checkInteraction(isClick) {
            if (!camera) return;
            raycaster.setFromCamera(center, camera);
            const intersects = raycaster.intersectObjects(scene.children);
            
            const msg = document.getElementById('interact-msg');
            let found = false;

            for(let hit of intersects) {
                if(hit.distance > 8) continue; 

                if(hit.object.userData.type === 'quiz') {
                    found = true;
                    msg.innerText = "[클릭] 힌트 얻기";
                    msg.style.display = 'block';
                    if(isClick) openQuiz(hit.object);
                    break;
                } else if (hit.object.userData.type === 'door') {
                    found = true;
                    if(hintsCollected >= 5) {
                        msg.innerText = "[클릭] 다음 방으로 탈출";
                        msg.style.color = "#00ff00";
                    } else {
                        msg.innerText = `잠겨있음 (${hintsCollected}/5)`;
                        msg.style.color = "#ff0000";
                    }
                    msg.style.display = 'block';
                    if(isClick && hintsCollected >= 5) nextLevel();
                    break;
                }
            }
            if(!found) msg.style.display = 'none';
        }

        function openQuiz(boxMesh) {
            activeQuizBox = boxMesh;
            const q = currentRoomQuizDeck.pop(); 
            if(!q) return; 

            document.getElementById('quiz-subject').innerText = `[${subjects[currentSubjectIndex]}] 문제`;
            document.getElementById('quiz-text').innerText = q.q;
            
            const optsDiv = document.getElementById('quiz-options');
            optsDiv.innerHTML = '';
            q.o.forEach((opt, idx) => {
                const btn = document.createElement('button');
                btn.className = 'quiz-btn';
                btn.innerText = `${idx+1}. ${opt}`;
                btn.onclick = () => solveQuiz(idx === q.a);
                optsDiv.appendChild(btn);
            });

            controls.unlock();
            document.getElementById('quiz-modal').style.display = 'block';
        }

        function solveQuiz(isCorrect) {
            document.getElementById('quiz-modal').style.display = 'none';
            controls.lock(); 

            if(isCorrect) {
                hintsCollected++;
                document.getElementById('hint-count').innerText = hintsCollected;
                playTone(600, 'sine', 0.2); 
                
                scene.remove(activeQuizBox);
                activeQuizBox.visible = false; 
                activeQuizBox.userData.type = 'solved';
                
                if(hintsCollected >= 5) {
                    doorMesh.material.color.set(0x00ff00);
                    playTone(800, 'sine', 0.5); 
                }
            } else {
                playTone(100, 'sawtooth', 0.5); 
                currentRoomQuizDeck.push(quizData[subjects[currentSubjectIndex]][Math.floor(Math.random()*5)]); 
            }
        }

        function nextLevel() {
            currentSubjectIndex++;
            if(currentSubjectIndex >= subjects.length) {
                gameOver("축하합니다! 모든 악몽에서 탈출했습니다!", true);
            } else {
                while(scene.children.length > 0){ scene.remove(scene.children[0]); }
                initThree(); 
                loadRoom(roomOrder[currentSubjectIndex]);
                world.bodies = []; 
                initPhysics(); 
                loadRoom(roomOrder[currentSubjectIndex]); 
                timer += 120;
            }
        }

        const clock = new THREE.Clock();

        function animate() {
            if(gameState !== 'PLAYING') return;
            requestAnimationFrame(animate);

            const dt = clock.getDelta();
            
            if (world) world.step(1/60, dt, 3);

            if(controls.isLocked) {
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                direction.y = 0; 
                direction.normalize();

                const side = new THREE.Vector3();
                side.crossVectors(camera.up, direction).normalize(); 

                const inputVelocity = new THREE.Vector3();

                if(keyState['KeyW']) inputVelocity.add(direction); 
                if(keyState['KeyS']) inputVelocity.sub(direction); 
                if(keyState['KeyA']) inputVelocity.add(side);      
                if(keyState['KeyD']) inputVelocity.sub(side);      

                if (inputVelocity.length() > 0) inputVelocity.normalize();

                playerBody.velocity.x = inputVelocity.x * playerSpeed;
                playerBody.velocity.z = inputVelocity.z * playerSpeed;

                if(keyState['Space'] && canJump) {
                    playerBody.velocity.y = 15; 
                    canJump = false;
                }
                
                checkInteraction(false);
            } else {
                playerBody.velocity.x = 0;
                playerBody.velocity.z = 0;
            }

            if(camera) {
                camera.position.copy(playerBody.position);
                camera.position.y += 0.5;
            }

            updateEnemy(dt);
            updateSpikes(dt); // 가시 업데이트

            if(enemyMesh && enemyBody) {
                enemyMesh.position.copy(enemyBody.position);
                enemyMesh.lookAt(playerBody.position.x, playerBody.position.y, playerBody.position.z);
            }

            if(renderer && scene && camera) renderer.render(scene, camera);
        }

        // --- 가시 공격 시스템 ---
        let attackCooldown = 0;

        function updateEnemy(dt) {
            const dir = new THREE.Vector3().subVectors(playerBody.position, enemyBody.position);
            const dist = dir.length();
            
            // 접촉 판정 (거리 4 이내면 사망 - 가시 사거리 내 혹은 몸체 접촉)
            if(dist < 4.0) {
                gameOver("검은 형체에게 잡혔습니다...");
                return;
            }

            // 가시 공격 (거리 15 이내면 발사)
            if (dist < 15.0 && attackCooldown <= 0) {
                shootSpikes();
                attackCooldown = 3.0; // 3초 쿨타임
            }
            if (attackCooldown > 0) attackCooldown -= dt;

            dir.normalize();
            
            enemyBody.velocity.x = dir.x * enemySpeed;
            enemyBody.velocity.z = dir.z * enemySpeed;

            // 점프 AI
            if(playerBody.position.y > enemyBody.position.y + 2 || Math.random() < 0.01) {
                if(Math.abs(enemyBody.velocity.y) < 0.1) {
                    enemyBody.velocity.y = 10;
                }
            }
        }

        function shootSpikes() {
            playSpikeSound();
            const spikeCount = 12;
            for(let i=0; i<spikeCount; i++) {
                const angle = (i / spikeCount) * Math.PI * 2;
                const dx = Math.cos(angle);
                const dz = Math.sin(angle);
                
                // 가시 메쉬 생성 (긴 원뿔)
                const geo = new THREE.ConeGeometry(0.2, 2, 8);
                geo.rotateX(Math.PI / 2); // 눕힘
                const mat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const mesh = new THREE.Mesh(geo, mat);
                
                mesh.position.copy(enemyBody.position);
                mesh.position.y += 1; // 몸통 높이에서 발사
                mesh.lookAt(mesh.position.x + dx, mesh.position.y, mesh.position.z + dz);
                
                scene.add(mesh);
                spikes.push({ mesh: mesh, dir: new THREE.Vector3(dx, 0, dz), life: 30.0, speed: 20.0 }); // life는 거리제한용
            }
        }

        function updateSpikes(dt) {
            for (let i = spikes.length - 1; i >= 0; i--) {
                const s = spikes[i];
                // 이동
                const moveDist = s.speed * dt;
                s.mesh.position.x += s.dir.x * moveDist;
                s.mesh.position.z += s.dir.z * moveDist;
                s.life -= moveDist; // 이동 거리만큼 수명 감소

                // 플레이어 충돌 체크 (간단한 거리 체크)
                const pDist = s.mesh.position.distanceTo(playerBody.position);
                if (pDist < 1.5) { // 플레이어 반지름 고려
                    gameOver("붉은 가시에 찔렸습니다...");
                    return;
                }

                // 수명(거리) 다하면 삭제 (약 30단위 이동 후)
                if (s.life <= 0) {
                    scene.remove(s.mesh);
                    spikes.splice(i, 1);
                }
            }
        }

        function gameOver(msg, isClear = false) {
            gameState = isClear ? 'CLEAR' : 'GAMEOVER';
            document.getElementById('gameover-screen').style.display = 'flex';
            document.getElementById('gameover-msg').innerText = isClear ? "ESCAPE!" : "GAME OVER";
            document.getElementById('gameover-msg').style.color = isClear ? "#00ff00" : "red";
            document.getElementById('death-reason').innerText = msg;
            
            const btnGroup = document.querySelector('.btn-group');
            if (isClear) btnGroup.style.display = 'none'; 
            else btnGroup.style.display = 'flex';

            if(!isClear) playScream();
            
            controls.unlock();
        }

        window.addEventListener('resize', () => {
            if (!camera || !renderer) return; 
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>